How to call paceval.-library functions from PHP
-----------------------------------------------

Since PHP 7.4 it is possible to easily call C functions from 
shared libraries (.DLL or .so).
Potentially you will have to change the php.ini to enable FFI
and to copy the correct library (.DLL or .so) to your file system, 
e.g. "/usr/bin/libpacevalARM64_sharedLIB.so", see below.

Links & Literature
[1] https://en.wikipedia.org/wiki/Foreign_function_interface
[2] https://wiki.php.net/rfc/ffi

In case the following example-code sniplets do not work for you,
please contact us at info@paceval.com.


example-code sniplets for ARM64 which you can easily adopt:
 https://github.com/paceval/paceval/blob/main/examples_sources/PHP_examples/example1.php
 https://github.com/paceval/paceval/blob/main/examples_sources/PHP_examples/example2.php
----------------------------------------------------------------------------------------

<?php

// PHP example 1

$paceval_ffi = FFI::cdef("
bool pacevalLibrary_Initialize(const char* initString_in);
bool pacevalLibrary_Free();
void* pacevalLibrary_CreateComputation(const char* functionString_in, unsigned long numberOfVariables_in,
    const char* variables_in, bool useInterval_in, void* paceval_callbackStatus_in);
double pacevalLibrary_dGetComputationResult(void* handle_pacevalComputation_in, double values_in[],
double* trustedMinResult_out, double* trustedMaxResult_out);
    bool pacevalLibrary_DeleteComputation(void* handle_pacevalComputation_in);
",
"/usr/bin/libpacevalARM64_sharedLIB.so"); // you can exchange the ARM64-library, e.g. to the x64-library

// call paceval-library functions to create a computation-object in memory, run a computation
// with trusted intervals and delete the computation-object from memory when we are done
$success = (bool) $paceval_ffi->pacevalLibrary_Initialize(null);

$valuesVariablesArray = FFI::new("double[2]");
$valuesVariablesArray[0] = 0.5;
$valuesVariablesArray[1] = 2.0;
$trustedMinResult = FFI::new("double");
$trustedMaxResult = FFI::new("double");

$handle_pacevalComputation = $paceval_ffi->pacevalLibrary_CreateComputation("-sin(x*cos(x))^(1/y)", 2, "x y", true, null);

$result = $paceval_ffi->pacevalLibrary_dGetComputationResult($handle_pacevalComputation, $valuesVariablesArray,
     FFI::addr($trustedMinResult), FFI::addr($trustedMaxResult));
var_dump($result); //-0.65180178245228
var_dump($trustedMinResult); //-0.65180178245231
var_dump($trustedMaxResult); //-0.65180178245225

$success = (bool) $paceval_ffi->pacevalLibrary_DeleteComputation($handle_pacevalComputation);
$success = (bool) $paceval_ffi->pacevalLibrary_Free();
?>

----------------------------------------------------------------------------------------

<?php

// PHP example 2

$paceval_ffi = FFI::cdef("
bool pacevalLibrary_Initialize(const char* initString_in);
bool pacevalLibrary_Free();
void* pacevalLibrary_CreateComputation(const char* functionString_in,
    unsigned long numberOfVariables_in, const char* variables_in, bool useInterval_in, void* paceval_callbackStatus_in);
bool pacevalLibrary_dGetComputationResultExt(void* handle_pacevalComputation_in, double values_in[],
    unsigned long numberOfCalculations_in, double* results_out, double* trustedMinResults_out,
double* trustedMaxResults_out, int* errorTypes_out);
double pacevalLibrary_dmathv(void* handle_pacevalComputation_out_in, int *errorType_out,
    const char* functionString_in, unsigned long numberOfVariables_in, const char* variables_in, double values_in[]);
bool pacevalLibrary_DeleteComputation(void* handle_pacevalComputation_in);
",
"/usr/bin/libpacevalARM64_sharedLIB.so");

// call paceval-library functions to create a computation-object in memory,
// run 1.000.000 computations for x in [-10, 10] and y set to 0.5 without trusted interval computing
// finally delete the computation-object from memory
$success = (bool) $paceval_ffi->pacevalLibrary_Initialize(null);

$valuesVariablesArrayExt = FFI::new("double[1000000 * 2]");
$results = FFI::new("double[1000000]");
$errorTypes = FFI::new("int[1000000]");
$delta_x = 20.0/1000000;
$errorType = FFI::new("int");

$handle_pacevalComputation = $paceval_ffi->pacevalLibrary_CreateComputation("(sin(x)*cos(y)*x*y)+(x/((x^2+y^2)))",
2, "x y", false, null);

for($iCount = 0; $iCount < 1000000; $iCount = $iCount + 1)
{
     $valuesVariablesArrayExt[$iCount*2] = -10 + $delta_x * $iCount;
     $valuesVariablesArrayExt[$iCount*2 + 1] = 0.5;
}

$hasError = $paceval_ffi->pacevalLibrary_dGetComputationResultExt($handle_pacevalComputation,
$valuesVariablesArrayExt, 1000000, FFI::addr($results[0]), null, null, FFI::addr($errorTypes[0]));
var_dump($results[0]); //-2.4868678245251
var_dump($results[300000]); //-1.5744671915086
var_dump($results[700000]); //-1.0821594992009
var_dump($results[999999]); //-2.287287969116

$success = (bool) $paceval_ffi->pacevalLibrary_DeleteComputation($handle_pacevalComputation);

$threadUsages = $paceval_ffi->pacevalLibrary_dmathv(null, FFI::addr($errorType), "paceval_NumberThreadUsages",
    0, "", null);
var_dump($threadUsages); //e.g. 12 threads

$success = (bool) $paceval_ffi->pacevalLibrary_Free();
?>

----------------------------------------------------------------------------------------

<?php

// PHP example a simple mathematical engine, e.g. to offload battery-operated IoT devices 

//EXAMPLE URL
// standard:  
//   https://paceval.dyndns.org/?call=paceval&functionString=-sin(x*cos(x))^(1/y)&numberOfVariables=2&variables=x;y&values=0.5;2
// interval:
//   https://paceval.dyndns.org/?call=paceval&functionString=-sin(x*cos(x))^(1/y)&numberOfVariables=2&variables=x;y&values=0.5;2&interval=yes

// calculates the function with the specified variables and values and 
// returns its result (optionally with upper and lower limit) in a json-coded format 

$call_str = $_GET["call"];
$numberOfVariables = $_GET["numberOfVariables"];
$variables_ar = explode(";", $_GET["variables"]);
$variables_str = implode( " ", $variables_ar); 
$values_ar = explode(";", $_GET["values"]);
$function_str = $_GET["functionString"];

$interval_str = $_GET["interval"];
if (($interval_str == "yes") || ($interval_str == "true"))
	$interval = true;

$paceval_ffi = FFI::cdef("
     bool pacevalLibrary_Initialize(const char* initString_in);
     bool pacevalLibrary_Free();
     void* pacevalLibrary_CreateComputation(const char* functionString_in,
          unsigned long numberOfVariables_in, const char* variables_in, bool useInterval_in, void* paceval_callbackStatus_in);
     double pacevalLibrary_dmathv(void* handle_pacevalComputation_out_in, int *errorType_out,
          const char* functionString_in, unsigned long numberOfVariables_in, const char* variables_in, double values_in[]);
          bool pacevalLibrary_DeleteComputation(void* handle_pacevalComputation_in);

     int pacevalLibrary_CreateErrorInformationText(void* handle_pacevalComputation_in, char* lastError_strMessage_out,
    	  char* lastError_strDetails_out);
     double pacevalLibrary_dGetComputationResult(void* handle_pacevalComputation_in, double values_in[],
          double* trustedMinResult_out, double* trustedMaxResult_out);
     bool pacevalLibrary_DeleteComputation(void* handle_pacevalComputation_in);
     ",
     "/usr/bin/libpaceval_linux_sharedLIB.so");

$result = FFI::new("double");
$errorType = FFI::new("int");

$success = (bool) $paceval_ffi->pacevalLibrary_Initialize(null);

if ($numberOfVariables > 0)
{
     $valuesVariablesArray = FFI::new("double[2]");
     for($iCount = 0; $iCount < $numberOfVariables; $iCount = $iCount + 1)
     {
          $valuesVariablesArray[$iCount] = $values_ar[$iCount];
     }
}
else
     $valuesVariablesArray = null;

if ($call_str == "paceval")
{
        $trustedMinResult = FFI::new("double");
        $trustedMaxResult = FFI::new("double");

        $timeCreate = microtime(true);
        $handle_pacevalComputation = $paceval_ffi->pacevalLibrary_CreateComputation($function_str, $numberOfVariables, $variables_str, $interval, null);
        $timeCreate = microtime(true) - $timeCreate; 

        $timeCalculate = microtime(true);
	$result = $paceval_ffi->pacevalLibrary_dGetComputationResult($handle_pacevalComputation, $valuesVariablesArray,
     		FFI::addr($trustedMinResult), FFI::addr($trustedMaxResult));
        $timeCalculate = microtime(true) - $timeCalculate; 
        $return_arr["result"] = $result;

        if ($interval == true)
        {
            	$return_arr["interval-min-result"] = $trustedMinResult->cdata;
		$return_arr["interval-max-result"] = $trustedMaxResult->cdata;
        }

        $functionLength = strlen($function_str);
        $function10chars = substr($function_str, 0, 10);
        if ($functionLength > 10)
        {
                 $function10chars = $function10chars . "(...)";
        }
        $return_arr["function-10chars"] = $function10chars;
        $return_arr["function-length"] = $functionLength;

        $maxLengthStr = $paceval_ffi->pacevalLibrary_CreateErrorInformationText($handle_pacevalComputation, null, null);
        $errorMessage_str = FFI::new("char[$maxLengthStr]");
        $errorDetails_str = FFI::new("char[$maxLengthStr]");
        $maxLengthStr = $paceval_ffi->pacevalLibrary_CreateErrorInformationText($handle_pacevalComputation, 
             FFI::addr($errorMessage_str[0]), FFI::addr($errorDetails_str[0]));
        $errorMessage = FFI::string($errorMessage_str);
        $errorDetails = FFI::string($errorDetails_str);

        $return_arr["error-type"] = $errorType->cdata . " " . $errorDetails;
        $threadUsages = $paceval_ffi->pacevalLibrary_dmathv(null, FFI::addr($errorType), "paceval_NumberThreadUsages", 0, "", null);
        $return_arr["number-of-thread-usages"] = $threadUsages;
        $cacheHitsACC = $paceval_ffi->pacevalLibrary_dmathv(null, FFI::addr($errorType), "paceval_NumberCacheHitsACC", 0, "", null);
        $return_arr["number-of-cache-hits"] = $cacheHitsACC;
        $return_arr["time-create"] = number_format($timeCreate, 6, ".", ",") . "s"; 
        $return_arr["time-calculate"] = number_format($timeCalculate, 6, ".", ",") . "s"; 
        $return_arr["error-message"] = $errorMessage;
        $handle_pacevalComputation_ret = FFI::cast("unsigned long", $handle_pacevalComputation);
        $return_arr["handle-pacevalComputation"] = $handle_pacevalComputation_ret->cdata;

        echo json_encode($return_arr);

        $success = (bool)$paceval_ffi->pacevalLibrary_DeleteComputation($handle_pacevalComputation);
        $success = (bool)$paceval_ffi->pacevalLibrary_Free();
}
?>